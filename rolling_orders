/* Goal 1: Create a subtable of orders per day. Make sure you decide whether you are counting invoices or line items.

Starting Code:
SELECT*
FROM dsv1069.orders */

SELECT DATE (paid_at) AS day
	,COUNT(DISTINCT invoice_id) AS orders
	,COUNT(DISTINCT line_item_id) AS line_items
FROM dsv1069.orders
GROUP BY DATE (paid_at);

/* Goal 2: “Check your joins”. We are still trying to count orders per day. In this step join the sub table from the previous exercise to the dates rollup table so we can get a row for every date. Check that the join works by just running a “select *” query. */

SELECT *
FROM dsv1069.dates_rollup
LEFT OUTER JOIN (
	SELECT DATE (orders.paid_at) AS day
		,COUNT(DISTINCT invoice_id) AS orders
		,COUNT(DISTINCT line_item_id) AS items_ordered
	FROM dsv1069.orders
	GROUP BY DATE (orders.paid_at)
	) daily_orders ON daily_orders.day = dates_rollup.date;

/* This SQL code is performing a LEFT OUTER JOIN between the "dsv1069.dates_rollup" table and a subquery that aggregates data from the "dsv1069.orders" table.

The "SELECT *" statement in the main query selects all columns from the "dsv1069.dates_rollup" table. This means that the result of the query will include all rows from the "dates_rollup" table, regardless of whether there is a match in the subquery.

The subquery is enclosed in parentheses and is aliased as "daily_orders". It selects three columns from the "orders" table: the day on which each order was paid, the number of unique invoice IDs for each day, and the number of unique line item IDs for each day.

The "GROUP BY" clause groups the results of the subquery by day, using the "DATE(orders.paid_at)" function to extract the date portion of the "paid_at" timestamp.

The LEFT OUTER JOIN links the "daily_orders" subquery to the "dates_rollup" table based on the equality of the "day" column in the subquery and the "date" column in the "dates_rollup" table.

A LEFT OUTER JOIN returns all the rows from the left-hand table (in this case, "dates_rollup"), and any matching rows from the right-hand table (in this case, "daily_orders"). If there is no match in the subquery for a particular row in the "dates_rollup" table, the corresponding columns from the "daily_orders" table will be NULL.

The result of this query will include all rows from the "dsv1069.dates_rollup" table, with additional columns for the aggregated data from the "dsv1069.orders" table. If there are no matching records in the "dsv1069.orders" table for a particular date, the corresponding columns in the result set will be NULL. */

/* Goal 3: “Clean up your Columns” In this step be sure to specify the columns you actually
want to return, and if necessary do any aggregation needed to get a count of the orders made
per day. */

SELECT dates_rollup.date
	,COALESCE(SUM(orders), 0) AS oders
	,COALESCE(SUM(items_ordered), 0) AS items_ordered
FROM dsv1069.dates_rollup
LEFT OUTER JOIN (
	SELECT DATE (orders.paid_at) AS day
		,COUNT(DISTINCT invoice_id) AS orders
		,COUNT(DISTINCT line_item_id) AS items_ordered
	FROM dsv1069.orders
	GROUP BY DATE (orders.paid_at)
	) daily_orders ON daily_orders.day = dates_rollup.date
GROUP BY dates_rollup.date;

/* Goal 4: Weekly Rollup. Figure out which parts of the JOIN condition need to be edited create 7 day rolling orders table. */

SELECT *
FROM dsv1069.dates_rollup
LEFT OUTER JOIN (
	SELECT DATE (orders.paid_at) AS day
		,COUNT(DISTINCT invoice_id) AS orders
		,COUNT(DISTINCT line_item_id) AS items_ordered
	FROM dsv1069.orders
	GROUP BY DATE (orders.paid_at)
	) daily_orders ON dates_rollup.date >= daily_orders.day
    AND
    dates_rollup.d7_ago < daily_orders.day;

/* This SQL code retrieves data from two tables: "dates_rollup" and "orders".

The first line, "SELECT *", indicates that all columns from both tables will be included in the output.

The second line specifies the source table for the query as "dsv1069.dates_rollup", where "dsv1069" is the name of the database schema and "dates_rollup" is the name of the table.

The third line indicates that the "LEFT OUTER JOIN" operation is being used to combine data from the "dates_rollup" table with a subquery result set that is generated by grouping data from the "orders" table by the date that each order was paid.

The subquery generates a result set that includes the date, the number of distinct invoice IDs, and the number of distinct line item IDs for each date that orders were paid.

The "ON" keyword is used to specify the join condition. In this case, the join condition specifies that only records from the "dates_rollup" table where the date is on or after the paid_at date in the "orders" table and less than seven days prior to the paid_at date will be included in the output.

Overall, this SQL code is used to generate a report that provides information about the number of orders and items ordered on each day within a specified time period, with an emphasis on days where there were no orders or items ordered. */
    
/* Goal 5: Column Cleanup. Finish creating the weekly rolling orders table, by performing any aggregation steps and naming your columns appropriately. */

SELECT dates_rollup.date
	,COALESCE(SUM(orders), 0) AS oders
	,COALESCE(SUM(items_ordered), 0) AS items_ordered
FROM dsv1069.dates_rollup
LEFT OUTER JOIN (
	SELECT date(orders.paid_at) AS day
		,COUNT(DISTINCT invoice_id) AS orders
		,COUNT(DISTINCT line_item_id) AS items_ordered
	FROM dsv1069.orders
	GROUP BY date(orders.paid_at)
	) daily_orders ON dates_rollup.date >= daily_orders.day
	AND dates_rollup.d7_ago < daily_orders.day
GROUP BY dates_rollup.date;
